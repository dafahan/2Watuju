<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Web Game Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #gameCanvas { width: 100vw; height: 100vh; display: block; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #ui > * { pointer-events: auto; }
        .block-btn { transition: all 0.2s; }
        .block-btn:hover { transform: scale(1.1); }
        .block-btn.selected { ring: 2px solid white; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    <div id="ui">
        <!-- Crosshair -->
        <div id="crosshair">
            <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                <line x1="20" y1="0" x2="20" y2="15" stroke="white" stroke-width="2"/>
                <line x1="20" y1="25" x2="20" y2="40" stroke="white" stroke-width="2"/>
                <line x1="0" y1="20" x2="15" y2="20" stroke="white" stroke-width="2"/>
                <line x1="25" y1="20" x2="40" y2="20" stroke="white" stroke-width="2"/>
            </svg>
        </div>

        <!-- HUD -->
        <div class="absolute top-4 left-4 text-white">
            <h1 class="text-2xl font-bold mb-2">3D Block World</h1>
            <div class="bg-black bg-opacity-50 p-4 rounded-lg">
                <p class="text-sm">WASD - Move</p>
                <p class="text-sm">Space - Jump</p>
                <p class="text-sm">Shift - Run</p>
                <p class="text-sm">Mouse - Look</p>
                <p class="text-sm">Left Click - Break Block</p>
                <p class="text-sm">Right Click - Place Block</p>
                <p class="text-sm">1-6 - Select Block Type</p>
            </div>
        </div>

        <!-- Block Selector -->
        <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 flex gap-2 bg-black bg-opacity-50 p-4 rounded-lg">
            <button class="block-btn selected w-12 h-12 bg-green-600 rounded border-2 border-white" data-color="#4ade80" data-type="grass">1</button>
            <button class="block-btn w-12 h-12 bg-stone-600 rounded border-2 border-gray-400" data-color="#78716c" data-type="stone">2</button>
            <button class="block-btn w-12 h-12 bg-yellow-700 rounded border-2 border-gray-400" data-color="#d97706" data-type="wood">3</button>
            <button class="block-btn w-12 h-12 bg-red-600 rounded border-2 border-gray-400" data-color="#dc2626" data-type="brick">4</button>
            <button class="block-btn w-12 h-12 bg-blue-500 rounded border-2 border-gray-400" data-color="#3b82f6" data-type="water">5</button>
            <button class="block-btn w-12 h-12 bg-purple-600 rounded border-2 border-gray-400" data-color="#9333ea" data-type="special">6</button>
        </div>

        <!-- Mini Map -->
        <div class="absolute top-4 right-4 w-48 h-48 bg-black bg-opacity-50 rounded-lg p-2">
            <canvas id="minimap" width="176" height="176" class="rounded"></canvas>
        </div>

        <!-- Stats -->
        <div class="absolute bottom-4 right-4 text-white bg-black bg-opacity-50 p-4 rounded-lg">
            <p class="text-sm">FPS: <span id="fps">0</span></p>
            <p class="text-sm">Blocks: <span id="blockCount">0</span></p>
            <p class="text-sm">Position: <span id="position">0, 0, 0</span></p>
        </div>
    </div>

    <script>
        // Game initialization
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 10, 500);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameCanvas').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Sky
        const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // World data
        const worldSize = 100;
        const blockSize = 2;
        const blocks = new Map();
        let selectedBlockType = 'grass';
        let selectedBlockColor = '#4ade80';

        // Create block geometry and materials
        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blockMaterials = {
            grass: new THREE.MeshLambertMaterial({ color: 0x4ade80 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x78716c }),
            wood: new THREE.MeshLambertMaterial({ color: 0xd97706 }),
            brick: new THREE.MeshLambertMaterial({ color: 0xdc2626 }),
            water: new THREE.MeshLambertMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.8 }),
            special: new THREE.MeshLambertMaterial({ color: 0x9333ea, emissive: 0x9333ea, emissiveIntensity: 0.3 })
        };

        // Generate terrain
        function generateTerrain() {
            const noiseScale = 0.05;
            for (let x = -worldSize/2; x < worldSize/2; x += blockSize) {
                for (let z = -worldSize/2; z < worldSize/2; z += blockSize) {
                    const height = Math.floor(Math.sin(x * noiseScale) * Math.cos(z * noiseScale) * 5 + 5) * blockSize;
                    for (let y = 0; y <= height; y += blockSize) {
                        const type = y === height ? 'grass' : 'stone';
                        createBlock(x, y, z, type);
                    }
                }
            }
        }

        // Block management
        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (blocks.has(key)) return;
            
            const block = new THREE.Mesh(blockGeometry, blockMaterials[type].clone());
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { type, position: { x, y, z } };
            
            scene.add(block);
            blocks.set(key, block);
            updateBlockCount();
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = blocks.get(key);
            if (block) {
                scene.remove(block);
                blocks.delete(key);
                updateBlockCount();
            }
        }

        function updateBlockCount() {
            document.getElementById('blockCount').textContent = blocks.size;
        }

        // Player controller
        const player = {
            position: new THREE.Vector3(0, 20, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.2,
            jumpPower: 0.5,
            onGround: false,
            height: 3
        };

        // Input handling
        const keys = {};
        const mouse = { x: 0, y: 0 };
        let isPointerLocked = false;

        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouse.x -= e.movementX * 0.002;
                mouse.y -= e.movementY * 0.002;
                mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouse.y));
            }
        });

        // Block interaction
        const raycaster = new THREE.Raycaster();
        const rayDirection = new THREE.Vector3();

        renderer.domElement.addEventListener('mousedown', (e) => {
            if (!isPointerLocked) return;
            
            camera.getWorldDirection(rayDirection);
            raycaster.set(camera.position, rayDirection);
            
            const intersects = raycaster.intersectObjects([...blocks.values()]);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                const pos = hit.object.userData.position;
                
                if (e.button === 0) { // Left click - remove
                    removeBlock(pos.x, pos.y, pos.z);
                } else if (e.button === 2) { // Right click - place
                    const normal = hit.face.normal;
                    const newPos = {
                        x: pos.x + normal.x * blockSize,
                        y: pos.y + normal.y * blockSize,
                        z: pos.z + normal.z * blockSize
                    };
                    createBlock(newPos.x, newPos.y, newPos.z, selectedBlockType);
                }
            }
        });

        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

        // Block type selection
        document.querySelectorAll('.block-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                document.querySelector('.block-btn.selected')?.classList.remove('selected', 'border-white');
                btn.classList.add('selected', 'border-white');
                selectedBlockType = btn.dataset.type;
                selectedBlockColor = btn.dataset.color;
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === String(index + 1)) {
                    btn.click();
                }
            });
        });

        // Physics and movement
        function updatePlayer() {
            const speed = keys['shift'] ? player.speed * 2 : player.speed;
            
            // Movement
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            
            if (keys['w']) player.velocity.add(forward.multiplyScalar(speed));
            if (keys['s']) player.velocity.add(forward.multiplyScalar(-speed));
            if (keys['a']) player.velocity.add(right.multiplyScalar(-speed));
            if (keys['d']) player.velocity.add(right.multiplyScalar(speed));
            
            // Jump
            if (keys[' '] && player.onGround) {
                player.velocity.y = player.jumpPower;
                player.onGround = false;
            }
            
            // Gravity
            player.velocity.y -= 0.02;
            
            // Apply velocity
            player.position.add(player.velocity);
            
            // Ground collision
            const groundY = getGroundHeight(player.position.x, player.position.z) + player.height;
            if (player.position.y <= groundY) {
                player.position.y = groundY;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            // Friction
            player.velocity.x *= 0.8;
            player.velocity.z *= 0.8;
            
            // Update camera
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = mouse.x;
            camera.rotation.x = mouse.y;
            
            // Update position display
            document.getElementById('position').textContent = 
                `${Math.floor(player.position.x)}, ${Math.floor(player.position.y)}, ${Math.floor(player.position.z)}`;
        }

        function getGroundHeight(x, z) {
            let maxY = 0;
            for (let y = 0; y < 50; y += blockSize) {
                const key = `${Math.floor(x/blockSize)*blockSize},${y},${Math.floor(z/blockSize)*blockSize}`;
                if (blocks.has(key)) {
                    maxY = y;
                }
            }
            return maxY;
        }

        // Mini map
        function updateMiniMap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const scale = 2;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw blocks
            blocks.forEach((block) => {
                const x = (block.position.x + worldSize/2) * scale;
                const z = (block.position.z + worldSize/2) * scale;
                
                if (x >= 0 && x < canvas.width && z >= 0 && z < canvas.height) {
                    ctx.fillStyle = block.material.color.getStyle();
                    ctx.fillRect(x-1, z-1, 2, 2);
                }
            });
            
            // Draw player
            const px = (player.position.x + worldSize/2) * scale;
            const pz = (player.position.z + worldSize/2) * scale;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(px, pz, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // FPS counter
        let frameCount = 0;
        let lastTime = performance.now();
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            updateFPS();
            
            // Update minimap less frequently
            if (frameCount % 30 === 0) {
                updateMiniMap();
            }
            
            renderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize game
        generateTerrain();
        animate();
    </script>
</body>
</html>